# Wait Profiler - DPA-Style Wait-Time Analysis
# Implements SolarWinds DPA equivalent wait-time methodology

receivers:
  # Comprehensive Wait Event Collection
  sqlquery/wait_time_analysis:
    driver: mysql
    datasource: "${env:MYSQL_USER}:${env:MYSQL_PASSWORD}@tcp(${env:MYSQL_ENDPOINT})/performance_schema"
    queries:
      # Multi-dimensional wait profiling
      - sql: |
          WITH wait_analysis AS (
            SELECT 
              ew.THREAD_ID,
              ew.EVENT_ID,
              ew.EVENT_NAME,
              ew.TIMER_WAIT/1000000000.0 as WAIT_TIME_MS,
              ew.TIMER_START,
              ew.TIMER_END,
              ew.OBJECT_SCHEMA,
              ew.OBJECT_NAME,
              ew.INDEX_NAME,
              ew.OBJECT_TYPE,
              ew.NESTING_EVENT_ID,
              ew.OPERATION,
              -- Enhanced wait categorization
              CASE 
                WHEN ew.EVENT_NAME LIKE 'wait/io/file%' THEN 
                  CASE
                    WHEN ew.EVENT_NAME LIKE '%innodb%' THEN 'IO_InnoDB'
                    WHEN ew.EVENT_NAME LIKE '%myisam%' THEN 'IO_MyISAM'
                    WHEN ew.EVENT_NAME LIKE '%temp%' THEN 'IO_Temp'
                    ELSE 'IO_Other'
                  END
                WHEN ew.EVENT_NAME LIKE 'wait/lock/table%' THEN 'Lock_Table'
                WHEN ew.EVENT_NAME LIKE 'wait/lock/metadata%' THEN 'Lock_Metadata'
                WHEN ew.EVENT_NAME LIKE 'wait/synch/mutex%' THEN 
                  CASE
                    WHEN ew.EVENT_NAME LIKE '%innodb%' THEN 'Mutex_InnoDB'
                    ELSE 'Mutex_Other'
                  END
                WHEN ew.EVENT_NAME LIKE 'wait/synch/cond%' THEN 'Condition'
                WHEN ew.EVENT_NAME LIKE 'wait/synch/rwlock%' THEN 'RWLock'
                WHEN ew.EVENT_NAME LIKE 'wait/io/socket%' THEN 'Network'
                ELSE 'Other'
              END as WAIT_CATEGORY,
              -- Get current statement
              (SELECT es.SQL_TEXT 
               FROM events_statements_current es
               WHERE es.THREAD_ID = ew.THREAD_ID 
                 AND es.NESTING_EVENT_ID = ew.NESTING_EVENT_ID
               LIMIT 1) as CURRENT_STATEMENT,
              -- Get statement digest
              (SELECT es.DIGEST 
               FROM events_statements_current es
               WHERE es.THREAD_ID = ew.THREAD_ID 
                 AND es.NESTING_EVENT_ID = ew.NESTING_EVENT_ID
               LIMIT 1) as STATEMENT_DIGEST,
              -- Connection info
              t.PROCESSLIST_ID,
              t.PROCESSLIST_USER,
              t.PROCESSLIST_HOST,
              t.PROCESSLIST_DB,
              t.PROCESSLIST_COMMAND,
              t.PROCESSLIST_STATE,
              t.PROCESSLIST_TIME
            FROM events_waits_current ew
            JOIN threads t ON ew.THREAD_ID = t.THREAD_ID
            WHERE ew.TIMER_WAIT > 0
              AND t.TYPE = 'FOREGROUND'
          )
          SELECT 
            WAIT_CATEGORY,
            COUNT(*) as ACTIVE_WAITS,
            SUM(WAIT_TIME_MS) as TOTAL_WAIT_MS,
            AVG(WAIT_TIME_MS) as AVG_WAIT_MS,
            MIN(WAIT_TIME_MS) as MIN_WAIT_MS,
            MAX(WAIT_TIME_MS) as MAX_WAIT_MS,
            STDDEV(WAIT_TIME_MS) as STDDEV_WAIT_MS,
            COUNT(DISTINCT THREAD_ID) as AFFECTED_THREADS,
            COUNT(DISTINCT STATEMENT_DIGEST) as UNIQUE_QUERIES,
            GROUP_CONCAT(DISTINCT CONCAT(OBJECT_SCHEMA, '.', OBJECT_NAME)) as AFFECTED_OBJECTS
          FROM wait_analysis
          GROUP BY WAIT_CATEGORY
        metrics:
          - metric_name: mysql.wait.profile.multidimensional
            value_column: "TOTAL_WAIT_MS"
            data_type: gauge
            attribute_columns:
              - WAIT_CATEGORY
              - ACTIVE_WAITS
              - AVG_WAIT_MS
              - MAX_WAIT_MS
              - STDDEV_WAIT_MS
              - AFFECTED_THREADS
              - UNIQUE_QUERIES
              - AFFECTED_OBJECTS
        collection_interval: 5s

      # Lock chain analysis
      - sql: |
          WITH lock_analysis AS (
            SELECT 
              mdl1.OBJECT_TYPE,
              mdl1.OBJECT_SCHEMA,
              mdl1.OBJECT_NAME,
              mdl1.LOCK_TYPE as WAITING_LOCK_TYPE,
              mdl1.LOCK_STATUS,
              mdl1.OWNER_THREAD_ID as WAITING_THREAD,
              -- Find blocking thread
              (SELECT mdl2.OWNER_THREAD_ID 
               FROM metadata_locks mdl2
               WHERE mdl2.OBJECT_SCHEMA = mdl1.OBJECT_SCHEMA
                 AND mdl2.OBJECT_NAME = mdl1.OBJECT_NAME
                 AND mdl2.LOCK_STATUS = 'GRANTED'
                 AND mdl2.OWNER_THREAD_ID != mdl1.OWNER_THREAD_ID
               LIMIT 1) as BLOCKING_THREAD,
              -- Get waiting query
              (SELECT es.DIGEST_TEXT 
               FROM events_statements_current es
               WHERE es.THREAD_ID = mdl1.OWNER_THREAD_ID
               LIMIT 1) as WAITING_QUERY,
              -- Get thread wait time
              (SELECT SUM(ew.TIMER_WAIT)/1000000000.0
               FROM events_waits_current ew
               WHERE ew.THREAD_ID = mdl1.OWNER_THREAD_ID
                 AND ew.EVENT_NAME LIKE 'wait/lock%') as WAIT_TIME_MS
            FROM metadata_locks mdl1
            WHERE mdl1.LOCK_STATUS = 'PENDING'
          ),
          blocking_info AS (
            SELECT 
              la.*,
              -- Get blocking query
              (SELECT es.DIGEST_TEXT 
               FROM events_statements_current es
               WHERE es.THREAD_ID = la.BLOCKING_THREAD
               LIMIT 1) as BLOCKING_QUERY,
              -- Get blocking thread runtime
              (SELECT t.PROCESSLIST_TIME
               FROM threads t
               WHERE t.THREAD_ID = la.BLOCKING_THREAD) as BLOCKING_RUNTIME_SEC
            FROM lock_analysis la
          )
          SELECT 
            COUNT(*) as LOCK_WAIT_COUNT,
            MAX(WAIT_TIME_MS) as MAX_LOCK_WAIT_MS,
            COUNT(DISTINCT WAITING_THREAD) as BLOCKED_THREADS,
            COUNT(DISTINCT BLOCKING_THREAD) as BLOCKING_THREADS,
            GROUP_CONCAT(
              CONCAT(
                'Thread ', WAITING_THREAD, 
                ' waiting ', ROUND(WAIT_TIME_MS, 2), 'ms',
                ' on ', OBJECT_SCHEMA, '.', OBJECT_NAME,
                ' blocked by Thread ', BLOCKING_THREAD
              ) SEPARATOR '; '
            ) as LOCK_CHAINS
          FROM blocking_info
        metrics:
          - metric_name: mysql.lock.chain.analysis
            value_column: "LOCK_WAIT_COUNT"
            data_type: gauge
            attribute_columns:
              - MAX_LOCK_WAIT_MS
              - BLOCKED_THREADS
              - BLOCKING_THREADS
              - LOCK_CHAINS
        collection_interval: 5s

      # Historical wait trends
      - sql: |
          SELECT 
            EVENT_NAME,
            OBJECT_NAME,
            COUNT_STAR as TOTAL_WAITS,
            SUM_TIMER_WAIT/1000000000.0 as TOTAL_WAIT_TIME_MS,
            AVG_TIMER_WAIT/1000000000.0 as AVG_WAIT_TIME_MS,
            MIN_TIMER_WAIT/1000000000.0 as MIN_WAIT_TIME_MS,
            MAX_TIMER_WAIT/1000000000.0 as MAX_WAIT_TIME_MS,
            -- Wait time percentiles (approximated)
            AVG_TIMER_WAIT/1000000000.0 * 1.5 as P75_WAIT_TIME_MS,
            AVG_TIMER_WAIT/1000000000.0 * 2.0 as P90_WAIT_TIME_MS,
            AVG_TIMER_WAIT/1000000000.0 * 3.0 as P95_WAIT_TIME_MS,
            -- Categorize wait severity
            CASE
              WHEN MAX_TIMER_WAIT/1000000000.0 > 5000 THEN 'critical'
              WHEN MAX_TIMER_WAIT/1000000000.0 > 1000 THEN 'high'
              WHEN MAX_TIMER_WAIT/1000000000.0 > 100 THEN 'medium'
              ELSE 'low'
            END as WAIT_SEVERITY
          FROM events_waits_summary_by_instance
          WHERE SUM_TIMER_WAIT > 0
            AND EVENT_NAME NOT LIKE 'idle%'
          ORDER BY SUM_TIMER_WAIT DESC
          LIMIT 50
        metrics:
          - metric_name: mysql.wait.history.summary
            value_column: "TOTAL_WAIT_TIME_MS"
            data_type: gauge
            attribute_columns:
              - EVENT_NAME
              - OBJECT_NAME
              - TOTAL_WAITS
              - AVG_WAIT_TIME_MS
              - MAX_WAIT_TIME_MS
              - P75_WAIT_TIME_MS
              - P90_WAIT_TIME_MS
              - P95_WAIT_TIME_MS
              - WAIT_SEVERITY
        collection_interval: 30s

      # Query-Wait correlation
      - sql: |
          WITH query_waits AS (
            SELECT 
              ess.DIGEST,
              ess.DIGEST_TEXT,
              ess.COUNT_STAR as EXECUTION_COUNT,
              ess.SUM_TIMER_WAIT/1000000000.0 as TOTAL_QUERY_TIME_MS,
              ess.AVG_TIMER_WAIT/1000000000.0 as AVG_QUERY_TIME_MS,
              -- Aggregate wait events for this query
              (SELECT SUM(ew.SUM_TIMER_WAIT)/1000000000.0
               FROM events_waits_summary_by_thread_by_event_name ew
               WHERE ew.THREAD_ID IN (
                 SELECT THREAD_ID 
                 FROM events_statements_history_long
                 WHERE DIGEST = ess.DIGEST
               )) as TOTAL_WAIT_TIME_MS,
              -- Dominant wait event
              (SELECT ew.EVENT_NAME
               FROM events_waits_summary_by_thread_by_event_name ew
               WHERE ew.THREAD_ID IN (
                 SELECT THREAD_ID 
                 FROM events_statements_history_long
                 WHERE DIGEST = ess.DIGEST
               )
               ORDER BY ew.SUM_TIMER_WAIT DESC
               LIMIT 1) as DOMINANT_WAIT_EVENT
            FROM events_statements_summary_by_digest ess
            WHERE ess.COUNT_STAR > 10
              AND ess.LAST_SEEN > DATE_SUB(NOW(), INTERVAL 1 HOUR)
          )
          SELECT 
            DIGEST,
            DIGEST_TEXT,
            EXECUTION_COUNT,
            AVG_QUERY_TIME_MS,
            IFNULL(TOTAL_WAIT_TIME_MS, 0) as TOTAL_WAIT_TIME_MS,
            -- Calculate wait percentage
            CASE 
              WHEN TOTAL_QUERY_TIME_MS > 0 
              THEN ROUND((IFNULL(TOTAL_WAIT_TIME_MS, 0) / TOTAL_QUERY_TIME_MS) * 100, 2)
              ELSE 0 
            END as WAIT_PERCENTAGE,
            IFNULL(DOMINANT_WAIT_EVENT, 'none') as DOMINANT_WAIT_EVENT
          FROM query_waits
          WHERE TOTAL_WAIT_TIME_MS > 0 OR AVG_QUERY_TIME_MS > 100
          ORDER BY TOTAL_WAIT_TIME_MS DESC
          LIMIT 50
        metrics:
          - metric_name: mysql.query.wait.correlation
            value_column: "TOTAL_WAIT_TIME_MS"
            data_type: gauge
            attribute_columns:
              - DIGEST
              - DIGEST_TEXT
              - EXECUTION_COUNT
              - AVG_QUERY_TIME_MS
              - WAIT_PERCENTAGE
              - DOMINANT_WAIT_EVENT
        collection_interval: 60s

processors:
  # Memory management
  memory_limiter:
    check_interval: 5s
    limit_percentage: 80
    spike_limit_percentage: 30

  batch:
    timeout: 5s
    send_batch_size: 1000

  # DPA-style wait analysis
  transform/wait_intelligence:
    error_mode: ignore
    metric_statements:
      - context: datapoint
        statements:
          # Calculate wait anomaly score
          - set(attributes["wait.anomaly_score"], 
                Case(
                  attributes["MAX_WAIT_MS"] > 5000, 100,
                  attributes["MAX_WAIT_MS"] > 1000, 80,
                  attributes["AVG_WAIT_MS"] > attributes["STDDEV_WAIT_MS"] * 3, 70,
                  attributes["ACTIVE_WAITS"] > 100, 60,
                  attributes["AVG_WAIT_MS"] > 100, 40,
                  20
                ))
            where metric.name == "mysql.wait.profile.multidimensional"
          
          # Identify wait patterns
          - set(attributes["wait.pattern"], 
                Case(
                  attributes["WAIT_CATEGORY"] =~ "Lock.*" AND attributes["MAX_WAIT_MS"] > 5000, "lock_contention",
                  attributes["WAIT_CATEGORY"] =~ "IO.*" AND attributes["AVG_WAIT_MS"] > 50, "io_bottleneck",
                  attributes["WAIT_CATEGORY"] =~ "Mutex.*" AND attributes["ACTIVE_WAITS"] > 100, "mutex_contention",
                  attributes["WAIT_CATEGORY"] == "Network" AND attributes["AVG_WAIT_MS"] > 10, "network_latency",
                  "normal"
                ))
            where metric.name == "mysql.wait.profile.multidimensional"
          
          # Lock chain severity
          - set(attributes["lock.severity"], 
                Case(
                  attributes["MAX_LOCK_WAIT_MS"] > 30000, "deadlock_risk",
                  attributes["MAX_LOCK_WAIT_MS"] > 10000, "critical",
                  attributes["MAX_LOCK_WAIT_MS"] > 5000, "high",
                  attributes["BLOCKED_THREADS"] > 5, "medium",
                  "low"
                ))
            where metric.name == "mysql.lock.chain.analysis" and
                  attributes["LOCK_WAIT_COUNT"] > 0
          
          # Query wait categorization
          - set(attributes["query.wait_category"], 
                Case(
                  attributes["WAIT_PERCENTAGE"] > 80, "wait_bound",
                  attributes["WAIT_PERCENTAGE"] > 50, "wait_heavy",
                  attributes["WAIT_PERCENTAGE"] > 20, "wait_moderate",
                  attributes["WAIT_PERCENTAGE"] > 0, "wait_light",
                  "cpu_bound"
                ))
            where metric.name == "mysql.query.wait.correlation"

  # Generate wait-based recommendations
  transform/wait_recommendations:
    error_mode: ignore
    metric_statements:
      - context: datapoint
        statements:
          # Create wait-specific recommendations
          - set(attributes["wait.recommendation"], 
                Case(
                  attributes["wait.pattern"] == "lock_contention",
                  "Review transaction isolation levels and query locking behavior",
                  
                  attributes["wait.pattern"] == "io_bottleneck",
                  "Consider faster storage, increase buffer pool, or optimize queries for less I/O",
                  
                  attributes["wait.pattern"] == "mutex_contention",
                  "High concurrency detected - consider connection pooling or query optimization",
                  
                  attributes["lock.severity"] == "deadlock_risk",
                  "URGENT: Potential deadlock - review lock ordering and transaction design",
                  
                  attributes["query.wait_category"] == "wait_bound",
                  "Query spending >80% time waiting - investigate " + attributes["DOMINANT_WAIT_EVENT"],
                  
                  ""
                ))
          
          # Calculate wait impact score
          - set(attributes["wait.impact_score"], 
                attributes["wait.anomaly_score"] * 
                attributes["AFFECTED_THREADS"] * 
                (attributes["TOTAL_WAIT_MS"] / 1000))
            where attributes["wait.anomaly_score"] != nil

  # New Relic specific attributes
  attributes/newrelic:
    actions:
      - key: newrelic.source
        value: opentelemetry
        action: insert
      - key: instrumentation.name
        value: mysql-wait-profiler-dpa
        action: insert
      - key: eventType
        value: "MySQLWaitAnalysis"
        action: insert

  # Entity synthesis
  attributes/entity_synthesis:
    actions:
      - key: entity.type
        value: "MYSQL_INSTANCE"
        action: insert
      - key: entity.guid
        value: "MYSQL|${env:CLUSTER_NAME}|${env:MYSQL_ENDPOINT}"
        action: insert

  resource:
    attributes:
      - key: service.name
        value: wait-profiler-dpa
        action: upsert

exporters:
  # New Relic OTLP exporter
  otlphttp/newrelic:
    endpoint: ${env:NEW_RELIC_OTLP_ENDPOINT}
    headers:
      api-key: ${env:NEW_RELIC_LICENSE_KEY}
    compression: gzip
    timeout: 30s

  # High-priority for critical waits
  otlphttp/newrelic_critical:
    endpoint: ${env:NEW_RELIC_OTLP_ENDPOINT}
    headers:
      api-key: ${env:NEW_RELIC_LICENSE_KEY}
      X-Priority: critical
    compression: none
    timeout: 10s

  debug:
    verbosity: detailed

service:
  pipelines:
    # Main wait analysis pipeline
    metrics/wait_analysis:
      receivers: [sqlquery/wait_time_analysis]
      processors: [
        memory_limiter, 
        batch, 
        transform/wait_intelligence,
        transform/wait_recommendations,
        attributes/newrelic,
        attributes/entity_synthesis,
        resource
      ]
      exporters: [otlphttp/newrelic, debug]
    
    # Critical wait events
    metrics/critical_waits:
      receivers: [sqlquery/wait_time_analysis]
      processors: [
        memory_limiter,
        batch,
        transform/wait_intelligence,
        attributes/newrelic,
        resource
      ]
      exporters: [otlphttp/newrelic_critical]

  extensions: [health_check, pprof]

extensions:
  health_check:
    endpoint: 0.0.0.0:13133
  
  pprof:
    endpoint: 0.0.0.0:1777